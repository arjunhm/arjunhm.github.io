{"componentChunkName":"component---src-templates-post-js","path":"/2024-05-20-log-structure/","result":{"data":{"markdownRemark":{"html":"<p>a place to write my thoughts regarding log-structured storage (LSM-Trees)</p>\n<h2>Components</h2>\n<h3>MemTable</h3>\n<ul>\n<li>in-memory. append only.</li>\n<li>all operations go here.</li>\n<li>keep it simple for now. like array of K-V pairs. implement skiplist later.</li>\n<li>flush to disk once size exceeds limit.</li>\n</ul>\n<h3>Attributes</h3>\n<ul>\n<li>size: the current size of the memtable</li>\n<li>limit: the max size it can accomodate.</li>\n<li>entries: list of key-value pairs</li>\n</ul>\n<h4>Operations</h4>\n<ul>\n<li>get(kv): returns kv pair if found, else error.</li>\n<li>put(kv): appends key-value pair. updates size. if <code class=\"language-text\">size</code> > <code class=\"language-text\">limit</code>, flush.</li>\n<li>delete(kv): appends key-value pair but marks as deleted. calls <code class=\"language-text\">put(kv)</code>.</li>\n<li>clear(): clears the contents of memtable.</li>\n<li>flush(): flushes contents of memtable to disk, and calls <code class=\"language-text\">clear()</code>.</li>\n</ul>\n<h3>Write Ahead Log (WAL)</h3>\n<ul>\n<li>on disk.</li>\n<li>all writes are added to WAL.</li>\n<li>used for crash recovery.</li>\n</ul>\n<h3>Bloom Filter</h3>\n<ul>\n<li>idk if its required immediately.</li>\n<li>work on this after SSTable.</li>\n<li>probablistic data structure that tells if object is in SSTable page or not.</li>\n<li>can yield false positives.</li>\n</ul>\n<h3>SSTable</h3>\n<ul>\n<li>append-only immutable page.</li>\n<li>merge with other SSTable once condition is met (determine condition later)</li>\n<li>has its own index?? maps key to byte offset of value</li>\n<li>Data: <code class=\"language-text\">&lt;key-size, val-size, key-data, val-data></code></li>\n</ul>\n<h2>info</h2>\n<ul>\n<li><code class=\"language-text\">put</code> operation does not update key-value, instead adds another key-value pair.</li>\n<li><code class=\"language-text\">get</code> operation reads last occurence of keys. terrible performance <code class=\"language-text\">O(n)</code>.</li>\n<li>index maps key to byte offset of value in SSTable.</li>\n<li>COMPACTION\n<ul>\n<li>break log into segments</li>\n<li>if segment exceeds size, compact two segments into new segment</li>\n<li>old segments serve read requests. block writes until merged.</li>\n<li>after merge, delete old files</li>\n<li>Read <a href=\"https://github.com/facebook/rocksdb/wiki/Compaction\">RocksDB Wiki</a></li>\n</ul>\n</li>\n<li>each segment (SSTable) has its own index</li>\n<li>delete operations is a PUT op with data=<code class=\"language-text\">&lt;key=key, val=null, deleted=true></code>. basically a tombstone.\n<ul>\n<li>data is removed when merging</li>\n</ul>\n</li>\n</ul>\n<h2>how lookup works (according to me)</h2>\n<ul>\n<li>check memtable</li>\n<li>check bloom filter</li>\n<li>load index from SSTable</li>\n<li>get offset from index</li>\n<li>search SSTable (disk read)</li>\n</ul>\n<h2>doubts</h2>\n<ul>\n<li>if each SSTable has its own index, do i have to load index into memory when reading from SSTable?</li>\n<li>if sparse index, how do you know which key to add?</li>\n<li>how does updating work in sparse index?</li>\n<li>Go doubts\n<ul>\n<li>how to tell if obj is loaded into memory?</li>\n<li>how to bring only part of obj into memory? Bring only an attribute of a struct.</li>\n<li>read/write to disk directly?</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Log-Structured Storage Notes","date":"2024-05-25T00:00:00.000Z"}}},"pageContext":{"slug":"/2024-05-20-log-structure/"}},"staticQueryHashes":[],"slicesMap":{}}